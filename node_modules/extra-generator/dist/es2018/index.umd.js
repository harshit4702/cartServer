(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.ExtraGenerator = {}));
}(this, (function (exports) { 'use strict';

    function* of(val) {
        yield val;
    }

    function* countdown(begin, end) {
        if (begin < end)
            return;
        for (let i = begin; i >= end; i--) {
            yield i;
        }
    }

    function* countup(begin, end) {
        if (begin > end)
            return;
        for (let i = begin; i <= end; i++) {
            yield i;
        }
    }

    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    function createCommonjsModule(fn) {
      var module = { exports: {} };
    	return fn(module, module.exports), module.exports;
    }

    var customError = createCommonjsModule(function (module, exports) {
    exports.CustomError = void 0;
    class CustomError extends Error {
        get name() {
            return this.constructor.name;
        }
    }
    exports.CustomError = CustomError;
    //# sourceMappingURL=custom-error.js.map
    });

    var expectedError = createCommonjsModule(function (module, exports) {
    exports.ExpectedError = void 0;

    class ExpectedError extends customError.CustomError {
    }
    exports.ExpectedError = ExpectedError;
    //# sourceMappingURL=expected-error.js.map
    });

    var assertionError = createCommonjsModule(function (module, exports) {
    exports.AssertionError = void 0;

    class AssertionError extends customError.CustomError {
    }
    exports.AssertionError = AssertionError;
    //# sourceMappingURL=assertion-error.js.map
    });

    var normalize_1 = createCommonjsModule(function (module, exports) {
    exports.normalize = void 0;
    function normalize(err) {
        var _a;
        return {
            name: err.name,
            message: err.message,
            stack: (_a = err.stack) !== null && _a !== void 0 ? _a : null
        };
    }
    exports.normalize = normalize;
    //# sourceMappingURL=normalize.js.map
    });

    var refute_1 = createCommonjsModule(function (module, exports) {
    exports.refute = void 0;

    function refute(condition, message) {
        if (condition)
            throw new expectedError.ExpectedError(message);
    }
    exports.refute = refute;
    //# sourceMappingURL=refute.js.map
    });

    var assert_1 = createCommonjsModule(function (module, exports) {
    exports.assert = void 0;

    function assert(condition, message) {
        if (!condition)
            throw new assertionError.AssertionError(message);
    }
    exports.assert = assert;
    //# sourceMappingURL=assert.js.map
    });

    var es2018 = createCommonjsModule(function (module, exports) {
    var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
    }) : (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        o[k2] = m[k];
    }));
    var __exportStar = (commonjsGlobal && commonjsGlobal.__exportStar) || function(m, exports) {
        for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
    };__exportStar(customError, exports);
    __exportStar(expectedError, exports);
    __exportStar(assertionError, exports);
    __exportStar(normalize_1, exports);
    __exportStar(refute_1, exports);
    __exportStar(assert_1, exports);
    //# sourceMappingURL=index.js.map
    });

    /**
     * @throws {Error}
     */
    function range(start, end, step = 1) {
        es2018.assert(step > 0, 'step parameter must be greater than 0');
        return rangeByUnsignedStep(start, end, step);
    }
    function* rangeByUnsignedStep(start, end, step) {
        if (start < end) {
            for (let i = start; i < end; i += step) {
                yield i;
            }
        }
        else {
            for (let i = start; i > end; i -= step) {
                yield i;
            }
        }
    }

    function* stringifyJSONStream(iterable) {
        yield '[';
        const iter = iterable[Symbol.iterator]();
        const firstResult = iter.next();
        if (!firstResult.done)
            yield JSON.stringify(firstResult.value);
        while (true) {
            const result = iter.next();
            if (result.done)
                break;
            yield ',' + JSON.stringify(result.value);
        }
        yield ']';
    }

    async function* stringifyJSONStreamAsync(asyncIterable) {
        yield '[';
        const iter = asyncIterable[Symbol.asyncIterator]();
        const firstResult = await iter.next();
        if (!firstResult.done)
            yield JSON.stringify(firstResult.value);
        while (true) {
            const result = await iter.next();
            if (result.done)
                break;
            yield ',' + JSON.stringify(result.value);
        }
        yield ']';
    }

    function* stringifyNDJSONStream(iterable) {
        const iter = iterable[Symbol.iterator]();
        const firstResult = iter.next();
        if (!firstResult.done)
            yield JSON.stringify(firstResult.value);
        while (true) {
            const result = iter.next();
            if (result.done)
                break;
            yield '\n' + JSON.stringify(result.value);
        }
    }

    async function* stringifyNDJSONStreamAsync(asyncIterable) {
        const iter = asyncIterable[Symbol.asyncIterator]();
        const firstResult = await iter.next();
        if (!firstResult.done)
            yield JSON.stringify(firstResult.value);
        while (true) {
            const result = await iter.next();
            if (result.done)
                break;
            yield '\n' + JSON.stringify(result.value);
        }
    }

    function* sse(message) {
        if (message.event)
            yield `event: ${message.event}\n`;
        for (const line of message.data.split('\n')) {
            yield `data: ${line}\n`;
        }
        if (message.id)
            yield `id: ${message.id}\n`;
        if (message.retry)
            yield `retry: ${message.retry}\n`;
        yield '\n';
    }

    exports.countdown = countdown;
    exports.countup = countup;
    exports.of = of;
    exports.range = range;
    exports.sse = sse;
    exports.stringifyJSONStream = stringifyJSONStream;
    exports.stringifyJSONStreamAsync = stringifyJSONStreamAsync;
    exports.stringifyNDJSONStream = stringifyNDJSONStream;
    exports.stringifyNDJSONStreamAsync = stringifyNDJSONStreamAsync;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=index.umd.js.map
